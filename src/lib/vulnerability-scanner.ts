import { NextRequest } from 'next/server';
import { logError, logWarning } from '@/lib/error-logger';


// Security event types
export enum SecurityEventType {
  BRUTE_FORCE_ATTEMPT = 'brute_force_attempt',
  CSRF_VIOLATION = 'csrf_violation',
  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',
  SUSPICIOUS_FILE_UPLOAD = 'suspicious_file_upload',
  XSS_ATTEMPT = 'xss_attempt',
  SQL_INJECTION_ATTEMPT = 'sql_injection_attempt',
  PATH_TRAVERSAL_ATTEMPT = 'path_traversal_attempt',
  UNAUTHORIZED_ACCESS = 'unauthorized_access',
  MALFORMED_REQUEST = 'malformed_request',
  SUSPICIOUS_USER_AGENT = 'suspicious_user_agent',
  DDOS_ATTACK = 'ddos_attack',
  SESSION_HIJACK_ATTEMPT = 'session_hijack_attempt'
}

// Security event severity levels
export enum SecurityEventSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// Security event interface
export interface SecurityEvent {
  id: string;
  type: SecurityEventType;
  severity: SecurityEventSeverity;
  timestamp: number;
  ip: string;
  userAgent: string;
  userId?: string;
  path: string;
  method: string;
  details: Record<string, unknown>;
  blocked: boolean;
  responseTime?: number;
}

// Security monitoring class
export class SecurityMonitor {
  public static events: SecurityEvent[] = []; // Made public for access
  private static readonly MAX_EVENTS = 10000; // Keep last 10k events in memory
  private static readonly ALERT_THRESHOLDS = {
    [SecurityEventType.BRUTE_FORCE_ATTEMPT]: { count: 5, window: 300000 }, // 5 in 5 minutes
    [SecurityEventType.CSRF_VIOLATION]: { count: 3, window: 300000 }, // 3 in 5 minutes
    [SecurityEventType.RATE_LIMIT_EXCEEDED]: { count: 10, window: 300000 }, // 10 in 5 minutes
    [SecurityEventType.XSS_ATTEMPT]: { count: 1, window: 60000 }, // 1 in 1 minute
    [SecurityEventType.SQL_INJECTION_ATTEMPT]: { count: 1, window: 60000 }, // 1 in 1 minute
    [SecurityEventType.DDOS_ATTACK]: { count: 1, window: 60000 } // 1 in 1 minute
  };

  // Log a security event
  static logEvent(
    type: SecurityEventType,
    severity: SecurityEventSeverity,
    req: NextRequest,
    details: Record<string, unknown> = {},
    blocked = false
  ): void {
    const event: SecurityEvent = {
      id: this.generateEventId(),
      type,
      severity,
      timestamp: Date.now(),
      ip: this.getClientIP(req),
      userAgent: req.headers.get('user-agent') || 'unknown',
      userId: req.headers.get('x-user-id') || undefined,
      path: req.nextUrl.pathname,
      method: req.method,
      details,
      blocked
    };

    // Add to events array
    this.events.push(event);

    // Maintain max events limit
    if (this.events.length > this.MAX_EVENTS) {
      this.events = this.events.slice(-this.MAX_EVENTS);
    }

    // Check for alert conditions
    this.checkAlertThresholds(type, event.ip);

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.warn(`Security Event [${severity.toUpperCase()}]: ${type}`, {
        ip: event.ip,
        path: event.path,
        details: event.details
      });
    }

    // In production, you would send to your logging service
    // await this.sendToLoggingService(event);
  }

  // Generate unique event ID
  private static generateEventId(): string {
    return `sec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Extract client IP
  private static getClientIP(req: NextRequest): string {
    return (
      req.headers.get('cf-connecting-ip') ||
      req.headers.get('x-real-ip') ||
      req.headers.get('x-forwarded-for')?.split(',')[0] ||
      'unknown'
    );
  }

  // Check if alert thresholds are exceeded
  private static checkAlertThresholds(type: SecurityEventType, ip: string): void {
    const threshold = this.ALERT_THRESHOLDS[type as keyof typeof this.ALERT_THRESHOLDS];
    if (!threshold) return;

    const now = Date.now();
    const windowStart = now - threshold.window;

    // Count events of this type from this IP in the time window
    const recentEvents = this.events.filter(event => 
      event.type === type &&
      event.ip === ip &&
      event.timestamp >= windowStart
    );

    if (recentEvents.length >= threshold.count) {
      this.triggerAlert(type, ip, recentEvents.length, threshold);
    }
  }

  // Trigger security alert
  private static triggerAlert(
    type: SecurityEventType,
    ip: string,
    eventCount: number,
    threshold: { count: number; window: number }
  ): void {
    const alert = {
      type: 'security_alert',
      eventType: type,
      ip,
      eventCount,
      threshold,
      timestamp: Date.now()
    };

    logError('Security Alert Triggered:', alert);

    // In production, send to alerting system
    // await this.sendAlert(alert);
  }

  // Get recent events for analysis
  static getRecentEvents(
    minutes = 60,
    type?: SecurityEventType,
    ip?: string
  ): SecurityEvent[] {
    const since = Date.now() - (minutes * 60 * 1000);
    
    return this.events.filter(event => {
      if (event.timestamp < since) return false;
      if (type && event.type !== type) return false;
      if (ip && event.ip !== ip) return false;
      return true;
    });
  }

  // Get security metrics
  static getSecurityMetrics(minutes = 60): {
    totalEvents: number;
    eventsByType: Record<string, number>;
    eventsBySeverity: Record<string, number>;
    topIPs: Array<{ ip: string; count: number }>;
    blockedRequests: number;
  } {
    const events = this.getRecentEvents(minutes);
    
    const eventsByType: Record<string, number> = {};
    const eventsBySeverity: Record<string, number> = {};
    const ipCounts: Record<string, number> = {};
    let blockedRequests = 0;

    events.forEach(event => {
      eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;
      eventsBySeverity[event.severity] = (eventsBySeverity[event.severity] || 0) + 1;
      ipCounts[event.ip] = (ipCounts[event.ip] || 0) + 1;
      if (event.blocked) blockedRequests++;
    });

    const topIPs = Object.entries(ipCounts)
      .map(([ip, count]) => ({ ip, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return {
      totalEvents: events.length,
      eventsByType,
      eventsBySeverity,
      topIPs,
      blockedRequests
    };
  }
}

// Vulnerability scanner for common attack patterns
export class VulnerabilityScanner {
  // XSS pattern detection
  private static readonly XSS_PATTERNS = [
    /<script[^>]*>.*?<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=/gi,
    /<iframe[^>]*>/gi,
    /<object[^>]*>/gi,
    /<embed[^>]*>/gi,
    /data:text\/html/gi,
    /vbscript:/gi
  ];

  // SQL injection pattern detection
  private static readonly SQL_INJECTION_PATTERNS = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION|CREATE|ALTER)\b)/gi,
    /('|('')|;|--|\/\*|\*\/)/gi,
    /(OR|AND)\s+\d+\s*=\s*\d+/gi,
    /\b(EXEC|EXECUTE)\b/gi,
    /\b(CAST|CONVERT|CHAR|VARCHAR)\b/gi
  ];

  // Path traversal patterns
  private static readonly PATH_TRAVERSAL_PATTERNS = [
    /\.\.[\/\\]/gi,
    /%2e%2e[\/\\]/gi,
    /\.\.%2f/gi,
    /\.\.%5c/gi,
    /%252e%252e/gi
  ];

  // Suspicious user agent patterns
  private static readonly SUSPICIOUS_USER_AGENTS = [
    /sqlmap/gi,
    /nikto/gi,
    /nessus/gi,
    /burp/gi,
    /nmap/gi,
    /acunetix/gi,
    /w3af/gi,
    /metasploit/gi
  ];

  // Scan request for XSS attempts
  static scanForXSS(input: string): boolean {
    return this.XSS_PATTERNS.some(pattern => pattern.test(input));
  }

  // Scan request for SQL injection attempts
  static scanForSQLInjection(input: string): boolean {
    return this.SQL_INJECTION_PATTERNS.some(pattern => pattern.test(input));
  }

  // Scan for path traversal attempts
  static scanForPathTraversal(path: string): boolean {
    return this.PATH_TRAVERSAL_PATTERNS.some(pattern => pattern.test(path));
  }

  // Scan user agent for suspicious patterns
  static scanUserAgent(userAgent: string): boolean {
    return this.SUSPICIOUS_USER_AGENTS.some(pattern => pattern.test(userAgent));
  }

  // Comprehensive request scan
  static scanRequest(req: NextRequest): {
    threats: Array<{
      type: SecurityEventType;
      severity: SecurityEventSeverity;
      details: Record<string, unknown>;
    }>;
  } {
    const threats: Array<{
      type: SecurityEventType;
      severity: SecurityEventSeverity;
      details: Record<string, unknown>;
    }> = [];

    const userAgent = req.headers.get('user-agent') || '';
    const url = req.nextUrl.toString();
    const pathname = req.nextUrl.pathname;

    // Scan URL for path traversal
    if (this.scanForPathTraversal(pathname)) {
      threats.push({
        type: SecurityEventType.PATH_TRAVERSAL_ATTEMPT,
        severity: SecurityEventSeverity.HIGH,
        details: { path: pathname }
      });
    }

    // Scan URL for XSS
    if (this.scanForXSS(url)) {
      threats.push({
        type: SecurityEventType.XSS_ATTEMPT,
        severity: SecurityEventSeverity.HIGH,
        details: { url }
      });
    }

    // Scan URL for SQL injection
    if (this.scanForSQLInjection(url)) {
      threats.push({
        type: SecurityEventType.SQL_INJECTION_ATTEMPT,
        severity: SecurityEventSeverity.CRITICAL,
        details: { url }
      });
    }

    // Scan user agent
    if (this.scanUserAgent(userAgent)) {
      threats.push({
        type: SecurityEventType.SUSPICIOUS_USER_AGENT,
        severity: SecurityEventSeverity.MEDIUM,
        details: { userAgent }
      });
    }

    // Scan query parameters
    for (const [key, value] of req.nextUrl.searchParams.entries()) {
      if (this.scanForXSS(value)) {
        threats.push({
          type: SecurityEventType.XSS_ATTEMPT,
          severity: SecurityEventSeverity.HIGH,
          details: { parameter: key, value }
        });
      }

      if (this.scanForSQLInjection(value)) {
        threats.push({
          type: SecurityEventType.SQL_INJECTION_ATTEMPT,
          severity: SecurityEventSeverity.CRITICAL,
          details: { parameter: key, value }
        });
      }
    }

    return { threats };
  }

  // Scan request body for threats
  static async scanRequestBody(
    body: string | FormData | null,
    contentType?: string
  ): Promise<{
    threats: Array<{
      type: SecurityEventType;
      severity: SecurityEventSeverity;
      details: Record<string, unknown>;
    }>;
  }> {
    const threats: Array<{
      type: SecurityEventType;
      severity: SecurityEventSeverity;
      details: Record<string, unknown>;
    }> = [];

    if (!body) return { threats };

    let textContent = '';

    if (typeof body === 'string') {
      textContent = body;
    } else if (body instanceof FormData) {
      // Scan form data values
      for (const [key, value] of body.entries()) {
        if (typeof value === 'string') {
          if (this.scanForXSS(value)) {
            threats.push({
              type: SecurityEventType.XSS_ATTEMPT,
              severity: SecurityEventSeverity.HIGH,
              details: { field: key, value }
            });
          }

          if (this.scanForSQLInjection(value)) {
            threats.push({
              type: SecurityEventType.SQL_INJECTION_ATTEMPT,
              severity: SecurityEventSeverity.CRITICAL,
              details: { field: key, value }
            });
          }
        }
      }
      return { threats };
    }

    // Scan text content
    if (this.scanForXSS(textContent)) {
      threats.push({
        type: SecurityEventType.XSS_ATTEMPT,
        severity: SecurityEventSeverity.HIGH,
        details: { contentType, bodyPreview: textContent.substring(0, 200) }
      });
    }

    if (this.scanForSQLInjection(textContent)) {
      threats.push({
        type: SecurityEventType.SQL_INJECTION_ATTEMPT,
        severity: SecurityEventSeverity.CRITICAL,
        details: { contentType, bodyPreview: textContent.substring(0, 200) }
      });
    }

    return { threats };
  }
}

// Incident response automation
export class IncidentResponse {
  private static readonly AUTO_BLOCK_THRESHOLDS = {
    [SecurityEventType.SQL_INJECTION_ATTEMPT]: 1, // Block immediately
    [SecurityEventType.XSS_ATTEMPT]: 3, // Block after 3 attempts
    [SecurityEventType.BRUTE_FORCE_ATTEMPT]: 5, // Block after 5 attempts
    [SecurityEventType.PATH_TRAVERSAL_ATTEMPT]: 2 // Block after 2 attempts
  };

  // Check if IP should be automatically blocked
  static shouldAutoBlock(ip: string, eventType: SecurityEventType): boolean {
    const threshold = this.AUTO_BLOCK_THRESHOLDS[eventType as keyof typeof this.AUTO_BLOCK_THRESHOLDS];
    if (!threshold) return false;

    const recentEvents = SecurityMonitor.getRecentEvents(15, eventType, ip); // 15 minutes
    return recentEvents.length >= threshold;
  }

  // Execute automated response
  static async executeResponse(
    ip: string,
    eventType: SecurityEventType,
    severity: SecurityEventSeverity
  ): Promise<{
    blocked: boolean;
    actions: string[];
  }> {
    const actions: string[] = [];

    // Check for auto-block
    if (this.shouldAutoBlock(ip, eventType)) {
      // In production, this would interface with your firewall/CDN
      actions.push(`Auto-blocked IP ${ip} for ${eventType}`);
      
      // Log the block action
      logWarning(`Automated IP block executed: ${ip} for ${eventType}`);
      
      return { blocked: true, actions };
    }

    // Non-blocking responses based on severity
    switch (severity) {
      case SecurityEventSeverity.CRITICAL:
        actions.push('Sent alert to security team');
        actions.push('Increased monitoring for this IP');
        break;
      case SecurityEventSeverity.HIGH:
        actions.push('Added to watch list');
        actions.push('Enabled detailed logging for this IP');
        break;
      case SecurityEventSeverity.MEDIUM:
        actions.push('Logged for review');
        break;
    }

    return { blocked: false, actions };
  }

  // Generate incident report
  static generateIncidentReport(
    startTime: number,
    endTime: number
  ): {
    period: { start: number; end: number };
    summary: {
      totalEvents: number;
      blockedIPs: string[];
      criticalEvents: number;
      affectedEndpoints: string[];
    };
    details: {
      eventTimeline: SecurityEvent[];
      attackPatterns: Record<string, number>;
      responseActions: string[];
    };
  } {
    const events = SecurityMonitor.events.filter(
      event => event.timestamp >= startTime && event.timestamp <= endTime
    );

    const blockedIPs = [...new Set(events.filter(e => e.blocked).map(e => e.ip))];
    const criticalEvents = events.filter(e => e.severity === SecurityEventSeverity.CRITICAL).length;
    const affectedEndpoints = [...new Set(events.map(e => e.path))];

    const attackPatterns: Record<string, number> = {};
    events.forEach(event => {
      attackPatterns[event.type] = (attackPatterns[event.type] || 0) + 1;
    });

    return {
      period: { start: startTime, end: endTime },
      summary: {
        totalEvents: events.length,
        blockedIPs,
        criticalEvents,
        affectedEndpoints
      },
      details: {
        eventTimeline: events.sort((a, b) => a.timestamp - b.timestamp),
        attackPatterns,
        responseActions: [] // Would be populated from actual response logs
      }
    };
  }
}